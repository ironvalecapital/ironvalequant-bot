import os, json, sys
from datetime import datetime
import tweepy

MAX_LEN = 260  # keep buffer under X limits

def split_for_x(text: str, limit: int = MAX_LEN):
    parts, buf = [], ""
    for line in text.split("\n"):
        if len(buf) + len(line) + 1 > limit:
            parts.append(buf.strip())
            buf = ""
        buf += line + "\n"
    if buf.strip():
        parts.append(buf.strip())
    return parts

def _get_env(name: str, fallbacks: list[str]):
    """
    Helper to fetch environment variables with fallback names.  Returns
    None if none of the names exist or contain a non-empty value.
    """
    # Try primary name first
    if name in os.environ and os.environ[name]:
        return os.environ[name]
    for fb in fallbacks:
        if fb in os.environ and os.environ[fb]:
            return os.environ[fb]
    return None


def get_x_client():
    """
    Construct a Tweepy client using either the new environment variable names
    (CONSUMER_KEY, CONSUMER_SECRET, ACCESS_TOKEN, ACCESS_TOKEN_SECRET) or the
    legacy X_API_KEY/X_API_SECRET/X_ACCESS_TOKEN/X_ACCESS_SECRET names.  Raises
    a RuntimeError if required credentials are missing.
    """
    consumer_key = _get_env("CONSUMER_KEY", ["X_API_KEY"])
    consumer_secret = _get_env("CONSUMER_SECRET", ["X_API_SECRET"])
    access_token = _get_env("ACCESS_TOKEN", ["X_ACCESS_TOKEN"])
    # Both X_ACCESS_SECRET and X_ACCESS_TOKEN_SECRET have been used previously
    access_token_secret = _get_env("ACCESS_TOKEN_SECRET", ["X_ACCESS_SECRET", "X_ACCESS_TOKEN_SECRET"])

    if not consumer_key or not consumer_secret:
        raise RuntimeError(
            "Missing consumer key/secret environment variables. Set CONSUMER_KEY and CONSUMER_SECRET (or legacy X_API_KEY/X_API_SECRET)."
        )
    if not access_token or not access_token_secret:
        raise RuntimeError(
            "Missing access token/secret environment variables. Set ACCESS_TOKEN and ACCESS_TOKEN_SECRET (or legacy X_ACCESS_TOKEN/X_ACCESS_SECRET/X_ACCESS_TOKEN_SECRET)."
        )

    return tweepy.Client(
        consumer_key=consumer_key,
        consumer_secret=consumer_secret,
        access_token=access_token,
        access_token_secret=access_token_secret,
        wait_on_rate_limit=True,
    )

def post_thread(client: tweepy.Client, text: str):
    parts = split_for_x(text)
    first = client.create_tweet(text=parts[0])
    reply_to = first.data["id"]
    ids = [reply_to]

    for p in parts[1:]:
        r = client.create_tweet(text=p, in_reply_to_tweet_id=reply_to)
        reply_to = r.data["id"]
        ids.append(reply_to)

    return ids

def main():
    payload = json.loads(sys.stdin.read() or "{}")
    text = (payload.get("text") or "").strip()
    title = (payload.get("title") or "IronvaleQuant Update").strip()

    if not text:
        raise SystemExit("No content in payload.text")

    # Add a header if you want consistency
    stamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC")
    final_text = f"{title} â€” {stamp}\n\n{text}".strip()

    client = get_x_client()
    tweet_ids = post_thread(client, final_text)

    # Print ids to logs for debugging
    print("Posted tweet ids:", tweet_ids)

if __name__ == "__main__":
    main()